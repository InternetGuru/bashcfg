#!/bin/bash

: ${CHANGELOG:=CHANGELOG}
: ${VERSION:=VERSION}

function err { echo "$0[error]: $@" >&2; return 1; }
#function err { printf -- "$0[error]: %s\n" "$@" >&2; return 1 }

# Are all changes committed?
function git_status_empty {
  [[ -z "$(git status --porcelain)" ]] && return 0
  err "Uncommited changes"
  return 1
}

# see http://nvie.com/posts/a-successful-git-branching-model/
#
# Current branch:
#
#  dev
#   - increment minor version, set patch to 0
#   - create release-major.minor branch
#
#  master, major.minor (eg. 1.10)
#   - increment patch version
#   - create hotfix-major.minor.patch branch
#
#  hotfix-x or release-x; alias current
#   - merge dev branch with current
#   - prompt to merge master with current
#   - ^ yes: merge master with current, add tag to master
#   - ^ success: prompt to merge major.minor with master
#   - ^ yes: merge major.minor with master
#   - prompt to delete current
#
#  feature
#   - update version history
#   - merge dev branch with feature
#   - prompt to delete branch
#
function git_flow {
  git_repo_exists || err "Use git_flow_init" || return 1
  local curbranch major minor patch tag master
  curbranch=$(gcb) || return $?
  git_status_empty || return $?
  oIFS=$IFS; IFS=.; read major minor patch < "$VERSION"; IFS=$oIFS
  master=${major}.$minor
  case ${curbranch%-*} in
    dev|master|$master)
      local branch code header
      branch="hotfix-${master}.$((++patch))"
      [[ $curbranch == dev ]] && branch="release-${major}.$((++minor))" && patch=0
      git checkout -b $branch
      code=$?
      [[ $code == 128 ]] && git checkout $branch && return $code
      [[ $code != 0 ]] && return $code
      echo ${major}.${minor}.$patch > $VERSION
      [[ $curbranch != dev ]] && git commit -am $branch && return $?
      header="${major}.${minor} | $(date "+%Y-%m-%d")"
      printf '\n%s\n\n%s\n' "$header" "$(<$CHANGELOG)" > $CHANGELOG
      git commit -am $branch && git_flow && git checkout $branch
      ;;
    hotfix)
      tag=${master}.$patch
      ;&
    release)
      [[ -z "$tag" ]] && tag=${master}.0
      ;&
    *)
      if [[ -z "$tag" ]]; then
        local tmpfile msg
        git rebase dev || return $?
        tmpfile="$(mktemp)"
        echo -e "\n# commits:" > "$tmpfile"
        git log dev..$curbranch --pretty=format:"#   %s" >> "$tmpfile"
        echo -e "\n# Please enter the message for your changes. Lines starting" >> "$tmpfile"
        echo -e "# with # and empty lines will be ignored." >> "$tmpfile"
        "${EDITOR:-vi}" "$tmpfile"
        sed -i '/^\s*\(#\|$\)/d;/^\s+/d' "$tmpfile"
        cat "$CHANGELOG" >> "$tmpfile" && mv "$tmpfile" "$CHANGELOG"
        git commit -am "Version history updated"
      fi
      git checkout dev && git merge --no-ff $curbranch || return $?
      [[ -n "$tag" ]] && confirm "Merge branch '$curbranch' into $master?" \
        && git checkout master && ( git checkout $master || git checkout -b $master ) \
        && git merge --no-ff $curbranch && git tag $tag \
        && confirm "Merge branch '$master' into master?" \
        && git checkout master && git merge $master && git checkout $master
      if confirm "Delete branch '$curbranch'?"; then
        git branch -r | grep origin/$curbranch$ >/dev/null \
        && git push origin :refs/heads/$curbranch
        git branch -d $curbranch
      fi
  esac
}

function git_flow_init {
  local commit checkout_master=true
  git_repo_exists 2>/dev/null || { git init; checkout_master=false; }
  git_status_empty || return $?
  commit=false
  $checkout_master \
    && { git checkout master 2>/dev/null \
    || { echo "Branch master not found"; return 1; }; }
  [[ ! -f $VERSION ]] && echo 0.0.0 > $VERSION \
    && echo "version file $VERSION created" && commit=true
  [[ ! -f $CHANGELOG ]] && touch $CHANGELOG \
    && echo "changelog file $CHANGELOG created" && commit=true
  $commit && git add -A && git commit -am "init git flow"
  git_branch_exists dev 2>/dev/null || git branch dev
  git checkout dev
}

function git_diff_inclusive {
  local from to
  IFS=. eval "read from junk to <<< ${1:-HEAD}"
  [[ -z $to ]] && to=$from
  git diff $from~1..$to $2
}

function git_delete_branch {
  git branch -d $1
  git push origin :refs/heads/$1
}

function git_delete_tag {
  git tag -d $1
  git push origin :refs/tags/$1
}

function git_log_since {
  git log --decorate --oneline ${1:+$1~1..}
}

function git_upstream {
  git branch -u "origin/${1:-$(gcb)}"
}

function git_branch_exists {
  git rev-parse --verify "$1" 1>/dev/null 2>/dev/null && return 0
  echo "Error: branch $1 does not exist" 1>&2
  return 1
}

function git_repo_exists {
  [[ -d .git ]] && return 0
  echo "Error: git repository does not exist" 1>&2
  return 1
}

# GIT aliases
alias gf='git_flow'
alias gfi='git_flow_init'
alias gdi='git_diff_inclusive'
alias gdb='git_delete_branch'
alias gdt='git_delete_tag'
alias gls='git_log_since'
alias gup='git_upstream'
alias gcb='git rev-parse --abbrev-ref HEAD' # git current branch
alias gb='git checkout -b'
alias gd='git diff'
alias gc='git commit'
alias gch='git checkout'
alias gl="git log --oneline --decorate --color --graph"
alias gla="gl --all"
alias gll="git log --all --color --graph --abbrev-commit --pretty=format:'%C(red)%h%Creset%C(yellow)%d%Creset %s %C(green)%cr%C(white dim) %an%Creset'"
alias gpush='git push --all; git push --tags'
alias gpull='git pull --all --tags; git fetch -p; git submodule update --init --recursive'
alias gpullhard='git reset --hard && gpull'
alias guc='git reset --soft HEAD~1' # git uncommit
alias gs='git status && git submodule status'
alias gaas='git add -A; gs'
